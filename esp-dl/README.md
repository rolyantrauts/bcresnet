Do not use the bcresnet_int8.onnx (this is for generic Linux/Windows/Mac CPUs).  
Use the bcresnet_float32.onnx generated by your training.  
Convert it using Espressif's tool (ESP-PPQ) to create the .espdl file.  
BCResNet on ESP-DL1.   
Operator Compatibility ESP-DL Supported Operators list.  
BCResNet LayerONNX OperatorESP-DL SupportNotesConv2DConv✅ SupportedHighly optimized on ESP32-S3 (uses vector instructions).  
BatchNormBatchNormalization✅ SupportedUsually fused into Conv during conversion.  
ReLURelu✅ Supported  
AdaptiveAvgPoolGlobalAveragePool✅ Supported Used in the final layer.  
AddAdd✅ SupportedUsed for the Residual connections.  
FlattenFlatten✅ Supported  
Sub-Spectral NormReshape / Trans✅ SupportedSSN relies on reshaping tensors. ESP-DL supports Reshape and Transpose.

Potential Issue: The "1D Branch" of BCResNet uses AdaptiveAvgPool2d((1, None)).

This pools the Frequency height to 1 but keeps the Time width.

Verdict: This should export as a standard AveragePool with a rectangular kernel (e.g., kernel_size=(5, 1)). ESP-DL supports 2D pooling, so this should work.

2. The Conversion Workflow (New Step Required)
You need to set up ESP-PPQ, which is Espressif's quantization tool. It takes your Float32 ONNX model + a few calibration audio files and produces the .espdl file.

Step A: Install ESP-PPQ

```
pip install esp-ppq
```

Added and example quantize_for_esp.py that Gemma3 pro kindly provided haven't tested as my sexuality is Pi
